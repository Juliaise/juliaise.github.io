<!DOCTYPE html>
<html lang="en-US">

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,maximum-scale=2">
    <link rel="stylesheet" type="text/css" media="screen" href="/assets/css/style.css?v=b4d134e51339789f3908a4747817f73ace7634be">

<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Regular Expressions Julia Style | JuLiase</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Regular Expressions Julia Style" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Julia users group, Adelaide, South Australia&lt;p&gt; A space for coders of all backgrounds and ability to talk Julia." />
<meta property="og:description" content="Julia users group, Adelaide, South Australia&lt;p&gt; A space for coders of all backgrounds and ability to talk Julia." />
<link rel="canonical" href="http://localhost:4000/resources/Regular%20Expressions%20Julia%20Style.html" />
<meta property="og:url" content="http://localhost:4000/resources/Regular%20Expressions%20Julia%20Style.html" />
<meta property="og:site_name" content="JuLiase" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Regular Expressions Julia Style" />
<script type="application/ld+json">
{"@type":"WebPage","headline":"Regular Expressions Julia Style","url":"http://localhost:4000/resources/Regular%20Expressions%20Julia%20Style.html","description":"Julia users group, Adelaide, South Australia&lt;p&gt; A space for coders of all backgrounds and ability to talk Julia.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZMMPPCHMBK"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZMMPPCHMBK');
</script>


<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->

  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          
            <a id="forkme_banner" href="https://github.com/Juliaise/juliaise.github.io">View on GitHub</a>
          

          <h1 id="project_title">JuLiase</h1>
          <h2 id="project_tagline">Julia users group, Adelaide, South Australia<p> A space for coders of all backgrounds and ability to talk Julia.</h2>

          
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Regular Expressions Julia Style</h1>
  </header>

  <div class="post-content">
    <h1 id="regular-expressions-julia-style">Regular Expressions Julia Style</h1>

<p><img src="/Users/mroughan/Dropbox/Classes_and_postgrads/Julia/XKCD/regular_expressions.png" alt="regular_expressions" style="zoom:80%;" /></p>

<p>https://xkcd.com/208/</p>

<h2 id="wwwwww">WWWWWW</h2>

<h6 id="what">What</h6>

<p>A <em>regular expression</em> or <em>regex</em> or <em>regexp</em> is a way of expressing a pattern.</p>

<h6 id="why">Why</h6>

<p>Regular expressions are used primarily as a means to find or match patterns of characters in strings. They can be used to validate text, or extract a part, or replace text.</p>

<p>As such, they are one of the most powerful tools available for working with text and data in general.</p>

<h6 id="when">When</h6>

<p>The concept arose in the 50s, but came into wider use with the rise of Unix tools such as <code class="language-plaintext highlighter-rouge">sed</code>.</p>

<p>The programming language <a href="https://www.perl.org/">Perl</a> brought in a alternative way of supporting regexes compared to the unix standard (in the late 80s), and the power of Perl’s version (particularly in Perl 5 in the 90s) lead to it becoming dominant.</p>

<h6 id="who">Who</h6>

<p>Kleene is responsible for much of the idea of formalising the core concept. It arose in the context of <em>regular languages</em> as a fundamental concept in computer science, but it is noteworthy that modern regular expressions are not formally regular for reasons I won’t delve into here.</p>

<p>Larry Wall has probably had the most influence on the modern Perl-like syntax for regular expressions.</p>

<p>N.B. PERL = <em>Practical Extraction and Report Language</em> or <em>Pathologically Eclectic Rubbish Lister</em>.</p>

<h6 id="where">Where</h6>

<p>Regexes (in their pure sense) are ideal for implementation in interpreted languages. A regex engine should be able to process the regex with one pass and finite memory.</p>

<p>Real regexes now use lots of tricks that break their pure nature, but also they have been ported into most modern high-level languages in some form, including some compiled languages like Julia. So perhaps their exact nature has become moot.</p>

<h6 id="how">How</h6>

<p>That’s what we are going to talk about now.</p>

<h2 id="perl-compatible-regular-expressions-pcre">Perl Compatible Regular Expressions (PCRE)</h2>

<p>Perl is a much hated language. What can you do? Haters r’ gonna hate.</p>

<p>But Perl was (and is) very useful for certain tasks, in particular working with text. One of the features that made it useful was a sophisticated regular expression engine and syntactic sugar to go with it.</p>

<p>Perl still exists. It is less favoured, but still 18th on <a href="https://www.tiobe.com/tiobe-index/">Tiobe’s list</a>.</p>

<p>However, one of its most lasting legacies is the <a href="https://www.pcre.org/">PCRE</a>. Many modern languages, Julia included, that have included regular expressions have done so through the PCRE libraries (written in C) or compatible code. The PCRE libraries are not 100% the same as Perl regexes. The detailed differences probably won’t matter for anyone except old-hand Perl programmers (e.g. PCRE has a hard limit on recusions and Perl doesn’t – not sure why I should have expected infinite recursion though).</p>

<p>Hence, what follows is a quick explanation of the PCRE syntax for regular expressions, which will apply for many modern programming languages We will follow that with some examples, and then an explanation of how to use these in Julia. Note that many tutorials on regexs are in the context of a particular language, and so have constructions based on that language, but I want to start with just the regex, and we will get into language specifics later.</p>

<p>A PCRE is a pattern match criteria consisting itself of a sequence of characters, but in the regex the characters can have special meanings. Some just mean themselves, e.g., standard ASCII characters like <code class="language-plaintext highlighter-rouge">'a'</code> mean themselves (by default). Others match special groups of characters, and others combine together to have special meanings. The Cheat Sheets <a href="https://perlmaven.com/regex-cheat-sheet">here</a>  and <a href="https://www.debuggex.com/cheatsheet/regex/pcre">here</a> are helpful, and cover more cases than I can here. I will just go over the basics, which are actually the things I use 95% of the time.</p>

<table>
  <thead>
    <tr>
      <th>Regex</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>.</td>
      <td>Any character except newline</td>
    </tr>
    <tr>
      <td>a</td>
      <td>The character a</td>
    </tr>
    <tr>
      <td>ab</td>
      <td>The string ab</td>
    </tr>
    <tr>
      <td>a|b</td>
      <td>a or b</td>
    </tr>
    <tr>
      <td>a*</td>
      <td>0 or more a’s</td>
    </tr>
    <tr>
      <td>a+</td>
      <td>1 or more a’s</td>
    </tr>
    <tr>
      <td>a?</td>
      <td>0 or 1 a’s</td>
    </tr>
    <tr>
      <td>a{2}</td>
      <td>exactly 2 a’s and there are many variants like a{2,5} or a{2,}</td>
    </tr>
    <tr>
      <td>\</td>
      <td><em>Escape</em> in combination with other characters (see next table)</td>
    </tr>
    <tr>
      <td>[abc]</td>
      <td>Any character from the set {a,b,c}</td>
    </tr>
    <tr>
      <td>[a-c]</td>
      <td>Any character from the range a to c</td>
    </tr>
    <tr>
      <td>[^abc]</td>
      <td>Any character except {a,b,c}</td>
    </tr>
    <tr>
      <td>[[:xxx:]]</td>
      <td>Special groups, e.g. xxx=alnum,alpha,ascii,lower,punt,space,word,…</td>
    </tr>
    <tr>
      <td>^</td>
      <td>Start of a string</td>
    </tr>
    <tr>
      <td>$</td>
      <td>End of a string</td>
    </tr>
    <tr>
      <td>(…)</td>
      <td>Group together and ‘capture’ (more on this later)</td>
    </tr>
    <tr>
      <td>(?:…)</td>
      <td>Group without capturing</td>
    </tr>
    <tr>
      <td>(?’name’: )</td>
      <td>Named capturing group</td>
    </tr>
  </tbody>
</table>

<p>Roughly these are divided into</p>

<ul>
  <li>literals, e.g., ‘a’</li>
  <li>alternation <code class="language-plaintext highlighter-rouge">|</code></li>
  <li>quantifiers, e.g., <code class="language-plaintext highlighter-rouge">+, *, ?, {2,4}</code></li>
  <li>character classes, e.g., <code class="language-plaintext highlighter-rouge">[abc],</code> <code class="language-plaintext highlighter-rouge">[[:xxx]]</code> and some of the escape codes below.</li>
  <li>assertions (anchors), e.g., <code class="language-plaintext highlighter-rouge">^</code> or <code class="language-plaintext highlighter-rouge">$</code></li>
  <li>capture groups and backreferences (see below)</li>
  <li>escape codes (see below).</li>
</ul>

<p>There are many more, but this is enough to get started in conjunction with the escape codes below.</p>

<table>
  <thead>
    <tr>
      <th>Regex</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>\d</td>
      <td>One digit = [0-9]</td>
    </tr>
    <tr>
      <td>\D</td>
      <td>One non-digit = [^\s]</td>
    </tr>
    <tr>
      <td>\s</td>
      <td>One whitespace (space, tab, endline) = [\f\t\n\r ]</td>
    </tr>
    <tr>
      <td>\S</td>
      <td>One non-whitespace = [^\s]</td>
    </tr>
    <tr>
      <td>\w</td>
      <td>One word character (a letter or digit or underscore) = [a-zA-Z0-9_]</td>
    </tr>
    <tr>
      <td>\W</td>
      <td>One non-word character = [^\w]</td>
    </tr>
    <tr>
      <td>\n</td>
      <td>Newline</td>
    </tr>
    <tr>
      <td>\t</td>
      <td>Tab</td>
    </tr>
    <tr>
      <td>\b</td>
      <td>Word boundary (an ‘anchor’ not a character match)</td>
    </tr>
    <tr>
      <td>\B</td>
      <td>Not a word boundary</td>
    </tr>
    <tr>
      <td>\\</td>
      <td>Backslash</td>
    </tr>
    <tr>
      <td>\(</td>
      <td>A left bracket, and similarly \ is used to escape any other character like or \^</td>
    </tr>
    <tr>
      <td>\1</td>
      <td>A backreference – related to grouping and capturing (more later)</td>
    </tr>
  </tbody>
</table>

<p>There are others. Note in particular the role of backslash in “escaping” other special characters such as (,),{,},\,*,.,?,+,[,], ^, $, …</p>

<p>Some regular expressions <em>capture</em> part of the regex. This is because when you match you often want to (i) check that a string has a format, and simultaneously (ii) extract a particular piece of the match. Round brackets let you do such captures. They are particularly useful when you want to find-and-replace some text in a single line of code. They can also be used to match something that has already appeared in your expression. For instance, to find double words.</p>

<p>There is much more to know here, but one extra topic I need to mention is that many regex engines (including Julia’s) are,  by default, <em>greedy</em>. That means they will match the biggest chunk they can. There are ways to specigfy alternatives (reluctant and so on).</p>

<p>A note on language compatibility: many languages handle strings in different ways. So although they use the PCRE2 format, they may require you to do extra things, e.g., \ is often used a special character, so you might need to double escape it, e.g., type something like <code class="language-plaintext highlighter-rouge">'\\d'</code> when inputting a regex. Julia is not one of those languages.</p>

<p>One final note. You may hear of PCRE2. This is the current version (PCRE is considered obsolete). There are subversions (series) inside these, but again, you are unlikely to care about most of the details as they are largely about performance, and consistency for Unicode, and you are unlikely to be using PCRE1 in most of your day-to-day.</p>

<h2 id="examples">Examples</h2>

<p>I will present a few examples to make this clearer. The examples have three parts</p>

<ol>
  <li>The regex (excluding the syntax that defines it as a regex, e.g., some form of quotation around the regex)</li>
  <li>A string</li>
  <li>The matching part of the string is indicated in bold if there is one.</li>
</ol>

<table>
  <thead>
    <tr>
      <th>Regex</th>
      <th>String</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>World</td>
      <td>Hello <strong>World</strong></td>
      <td> </td>
    </tr>
    <tr>
      <td>world</td>
      <td>Hello World</td>
      <td>no match because of the case</td>
    </tr>
    <tr>
      <td>.*World</td>
      <td><strong>Hello World</strong></td>
      <td>greedy match</td>
    </tr>
    <tr>
      <td>hat</td>
      <td>T<strong>hat</strong> was my red <strong>hat</strong></td>
      <td>Two possible matches</td>
    </tr>
    <tr>
      <td>^house</td>
      <td><strong>house</strong>keeper</td>
      <td> </td>
    </tr>
    <tr>
      <td>house$</td>
      <td>housekeeper</td>
      <td>no match because of the end-of-string</td>
    </tr>
    <tr>
      <td>[ba]+</td>
      <td><strong>ab</strong>out</td>
      <td> </td>
    </tr>
    <tr>
      <td>[\d]*</td>
      <td>The <strong>300</strong> Spartans</td>
      <td> </td>
    </tr>
    <tr>
      <td>\bcat\b</td>
      <td>The <strong>cat</strong> in the hat</td>
      <td> </td>
    </tr>
    <tr>
      <td>\bcat\b</td>
      <td>The catalogue</td>
      <td>no match because of no word boundary</td>
    </tr>
    <tr>
      <td>cat|cats</td>
      <td><strong>cat</strong>s</td>
      <td>matches the earliest alternative</td>
    </tr>
    <tr>
      <td>cat[s]?</td>
      <td><strong>cats</strong></td>
      <td>does the greedy match</td>
    </tr>
    <tr>
      <td>(\d\d):(\d{2}):(\d{2})</td>
      <td><strong>17:21:00</strong></td>
      <td>matches a time, capturing hh,mm,s[s]</td>
    </tr>
    <tr>
      <td>gr[ae]y</td>
      <td><strong>gray</strong></td>
      <td>could also match <strong>grey</strong></td>
    </tr>
    <tr>
      <td>abc{2}</td>
      <td>abcabc</td>
      <td>No match as it matches <strong>abcc</strong></td>
    </tr>
    <tr>
      <td>a(bc){2}</td>
      <td><strong>abcbc</strong></td>
      <td> </td>
    </tr>
    <tr>
      <td>a(b|c)</td>
      <td><strong>ab</strong></td>
      <td>Also matches <strong>ac</strong></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>Some bigger examples:</p>

<ul>
  <li>
    <p>Finding double words in text:</p>

    <div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="x">(</span><span class="o">\</span><span class="n">b</span><span class="x">(</span><span class="o">\</span><span class="n">w</span><span class="o">+</span><span class="x">)</span><span class="o">\</span><span class="n">b</span><span class="o">\</span><span class="n">s</span><span class="o">+\</span><span class="n">b</span><span class="o">\</span><span class="mi">2</span><span class="o">\</span><span class="n">b</span><span class="x">)</span>
</code></pre></div>    </div>

    <p>Explanation: the outer brackets are to capture the match (to use it). The inner brackets <code class="language-plaintext highlighter-rouge">(\w+)</code> capture a word. The later <code class="language-plaintext highlighter-rouge">\2</code> refers to this first word. So this regex is looking for a word <code class="language-plaintext highlighter-rouge">\b\w+\b</code>, then a set of at least one space, then a repeat of this word with appropripriate word boundaries.</p>
  </li>
  <li>
    <p>Match an email:</p>

    <div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">\</span><span class="n">b</span><span class="x">[</span><span class="o">\</span><span class="n">w</span><span class="o">-\.</span><span class="x">]</span><span class="o">+</span><span class="err">@</span><span class="o">\</span><span class="n">b</span><span class="x">([</span><span class="o">\</span><span class="n">w</span><span class="o">-</span><span class="x">]</span><span class="o">+\.</span><span class="x">){</span><span class="mi">1</span><span class="x">,</span><span class="mi">4</span><span class="x">}</span><span class="o">+</span><span class="x">[</span><span class="o">\</span><span class="n">w</span><span class="x">]</span><span class="o">\</span><span class="n">b</span>
</code></pre></div>    </div>

    <p>Explanation: An email like <code class="language-plaintext highlighter-rouge">matthew.roughan@adelaide.edu.au</code> has</p>

    <ol>
      <li>a name <code class="language-plaintext highlighter-rouge">[\w-\.]+</code>, which is a list of one or more word characters, but might also include some limited punctuation such as - or a full stop.</li>
      <li>the <code class="language-plaintext highlighter-rouge">@</code></li>
      <li>a set of 1-4 dot-separated pieces, <code class="language-plaintext highlighter-rouge">([\w-]+\.)</code>, e.g., adelaide.</li>
      <li>a final <code class="language-plaintext highlighter-rouge">com</code> or <code class="language-plaintext highlighter-rouge">edu</code> or other top-level domain.</li>
    </ol>

    <p>N.B. Actually emails can be more complicated than this, but this will find 99% of them. The name can actually contain other things like its own escaped characters</p>
  </li>
  <li>
    <p>Match a floating point number</p>
  </li>
</ul>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="x">[</span><span class="o">-+</span><span class="x">]</span><span class="o">?</span><span class="x">([</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="x">]</span><span class="o">*\.</span><span class="x">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="x">]</span><span class="o">+|</span><span class="x">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="x">]</span><span class="o">+</span><span class="x">)</span>
</code></pre></div></div>

<p>Explanation: Obv. As we are matching numbers like -0.42345, we are mainly matching digits, which we could do with <code class="language-plaintext highlighter-rouge">\d</code> or the range <code class="language-plaintext highlighter-rouge">[0-9]</code>. There is an arbitrary number of digits before the decimal, with an optional plus or minus at the start. Then there are digits after the decimal. Alternatively, we just allow an integer like 1234, with no decimal at all.</p>

<p>Once again, the real version of this is more complicated as you may have to take into account scientific notation and other variations. See <a href="https://www.regular-expressions.info/floatingpoint.html#:~:text=%5B0%2D9%5D%2B%7C,more%20digits%20(an%20integer).&amp;text=Any%20match%20must%20include%20at%20least%20one%20digit.">this</a> for a more complete version.</p>

<p>Other common uses: trim excessive whitespace, find HTML tags, verifying credit card numbers,</p>

<h2 id="julia-regex">Julia Regex</h2>

<p>The previous stuff was about the generic idea, but you also need a wayu to work with them in any given language. How do you do this in Julia?</p>

<h4 id="construction-of-regexes">Construction of regexes</h4>

<p>Julia has two main approaches to constructing regular expressions. The first uses a <em>string literal</em> modifier. Its very easy – you just put a <code class="language-plaintext highlighter-rouge">r</code> before the first float of string literal, e.g.,</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">regex</span> <span class="o">=</span> <span class="n">r</span><span class="s">"match this"</span>
</code></pre></div></div>

<p>That is the most common approach for me, but it has a key limitation in that sometimes you want to construct a regular expression programmatically using information that is only available at run time. For example you might want to test a name against a user input. Then you need to construct the regex using the constructor, e.g., the example above is</p>

<pre><code class="language-Julia">julia&gt; regex = Regex("match this")
</code></pre>

<p>However, the input to the constructor is a string, and this can be in turn created, for instance, by string interpolation or some other construction. For example:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="s">"this"</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">regex</span> <span class="o">=</span> <span class="kt">Regex</span><span class="x">(</span><span class="s">"match </span><span class="si">$</span><span class="s">x"</span><span class="x">)</span>
</code></pre></div></div>

<p>This approach is a little more flexible.</p>

<p>Triple quoted regex definitions are also supported, e.g., <code class="language-plaintext highlighter-rouge">r"""..."""</code> but I haven’t used these much.</p>

<h4 id="use-of-regexes">Use of regexes</h4>

<h6 id="search-and-match">Search and Match</h6>

<p>There is a function called <code class="language-plaintext highlighter-rouge">match</code>, e.g.,</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">match</span><span class="x">(</span><span class="n">r</span><span class="s">"(cat|dog)s?"</span><span class="x">,</span> <span class="s">"my mice are too big"</span><span class="x">)</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">println</span><span class="x">(</span><span class="n">m</span><span class="x">)</span>
<span class="nb">nothing</span>
</code></pre></div></div>

<p>Here there was no match, and so the function returns <code class="language-plaintext highlighter-rouge">nothing</code>. If instead there is a match, you get something like this:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">match</span><span class="x">(</span><span class="n">r</span><span class="s">"(cat|dog)s?"</span><span class="x">,</span> <span class="s">"my cats are dogs"</span><span class="x">)</span>
<span class="kt">RegexMatch</span><span class="x">(</span><span class="s">"cats"</span><span class="x">,</span> <span class="mi">1</span><span class="o">=</span><span class="s">"cat"</span><span class="x">)</span>
</code></pre></div></div>

<p>You can see that the return type is a <code class="language-plaintext highlighter-rouge">RegexMatch</code>, which is a little weird. A <code class="language-plaintext highlighter-rouge">RegexMatch</code> is a composite type that has fields:</p>

<ul>
  <li>match – a <code class="language-plaintext highlighter-rouge">SubString</code> containing the matched text;</li>
  <li>captures – a vector of capture groups;</li>
  <li>offset – the offset of the match;</li>
  <li>offsets – the offsets of the capture group; and</li>
  <li>regex – the regex used.</li>
</ul>

<p>So</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">match</span><span class="x">(</span><span class="n">r</span><span class="s">"(cat|dog)s?"</span><span class="x">,</span> <span class="s">"my cats are dogs"</span><span class="x">)</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">match</span>
<span class="s">"cats"</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">captures</span>
<span class="mi">1</span><span class="o">-</span><span class="n">element</span> <span class="kt">Vector</span><span class="x">{</span><span class="kt">Union</span><span class="x">{</span><span class="kt">Nothing</span><span class="x">,</span> <span class="kt">SubString</span><span class="x">{</span><span class="kt">String</span><span class="x">}}}</span><span class="o">:</span>
 <span class="s">"cat"</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">regex</span>
<span class="n">r</span><span class="s">"(cat|dog)s?"</span>
</code></pre></div></div>

<p>Note the differences between the captured group and the overall match.</p>

<p>There is an <code class="language-plaintext highlighter-rouge">eachmatch</code> which is an iterator, so you can do things like</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">r</span><span class="s">"a.a"</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">eachmatch</span><span class="x">(</span><span class="n">rx</span><span class="x">,</span> <span class="s">"a1a2a3a"</span><span class="x">)</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">m</span> <span class="k">in</span>  <span class="n">eachmatch</span><span class="x">(</span><span class="n">rx</span><span class="x">,</span> <span class="s">"a1a2a3a"</span><span class="x">)</span>
       		<span class="n">println</span><span class="x">(</span><span class="n">m</span><span class="x">)</span>
       <span class="k">end</span>
<span class="kt">RegexMatch</span><span class="x">(</span><span class="s">"a1a"</span><span class="x">)</span>
<span class="kt">RegexMatch</span><span class="x">(</span><span class="s">"a3a"</span><span class="x">)</span>
</code></pre></div></div>

<p>There is also a <code class="language-plaintext highlighter-rouge">occursin</code> to just check if the thing you are looking for exists.</p>

<p>Underlying all of these is a <code class="language-plaintext highlighter-rouge">needle, haystack</code> philosophy, i.e., the input of the “needle” (the thing you are looking for) precedes the “haystack” (the thing you are looking through).</p>

<p>There are some optional extras in some of these functions, but you can look them up yourself. Named capture groups and so on can all be used in cute ways.</p>

<p>N.B. Names of some of these functions have changed over time. These seem to be stable now.</p>

<h6 id="replacement-and-substitution">Replacement and substitution</h6>

<p>The other main use for regexes, historically at least, is in directly replacing parts of a string. You can use regexs very simply in replacements to replace the regex with a string as follows:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">str</span> <span class="o">=</span> <span class="n">replace</span><span class="x">(</span><span class="s">"catsss are cool"</span><span class="x">,</span> <span class="n">r</span><span class="s">"cats+"</span> <span class="o">=&gt;</span> <span class="s">"dogs"</span><span class="x">)</span>
</code></pre></div></div>

<p>However, often you don’t want to replace the whole match. You want to replace, but reuse. You need to know an extra thing in order to do such replacement: to do something more sophisticated than just replace a string with a string, you will need a second type of object called a <code class="language-plaintext highlighter-rouge">SubstitutionString</code> which is specified by using <code class="language-plaintext highlighter-rouge">s"..."</code>. For example:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">str</span> <span class="o">=</span> <span class="n">replace</span><span class="x">(</span><span class="s">"cats"</span><span class="x">,</span> <span class="n">r</span><span class="s">"(\w+)s"</span> <span class="o">=&gt;</span> <span class="n">s</span><span class="s">"</span><span class="se">\1</span><span class="s">"</span><span class="x">)</span>
<span class="s">"cat"</span>
</code></pre></div></div>

<p>Mind you this example isn’t the best way to remove an ‘s’ from a string, but it might give you the idea.</p>

<p>Capture groups are incredibly powerful, but also not trivial to use well.</p>

<p>Also note that <code class="language-plaintext highlighter-rouge">replace</code> is heavily overloaded, so pay attention to which version you are using.</p>

<h2 id="more-tips-and-tricks">More Tips and Tricks</h2>

<h6 id="performance">Performance</h6>

<p>There are untold ways to create regexes for any occasion. Unfortunately, it is highly opaque to understand which approaches will be fast, and which slow.</p>

<p>Some approaches that can help:</p>

<ul>
  <li>Be more specific (avoid generic matches that then somehow get refined). Often a longer regex is better, because it will be more specific. The faster you throw out non-matches the better.</li>
  <li>On a related point, showing something can’t match is usually more work than finding a match. Try to do the latter.</li>
  <li>Cut down on backtracking – that occurs when a matcher must go back through a string to find out if something match. Matches that just look for a pattern, without checking back can be much faster. Backrefences are the obvious case, but it isn’t always obvious how to avoid backtracking altogether.</li>
  <li>Learn about consumption (see below).</li>
  <li>Anchors like ^ and $ and \b can help a lot because they reduce the number of possible places to look for a match.</li>
  <li>Order matters. As with <code class="language-plaintext highlighter-rouge">if/else/then</code> control flow, with alternatives specified by <code class="language-plaintext highlighter-rouge">|</code> you want the most common case first so that when you hit that case (often) you avoid the work of the other cases.</li>
</ul>

<p>See <a href="https://www.loggly.com/blog/five-invaluable-techniques-to-improve-regex-performance/">here</a> for more details.</p>

<h6 id="consumption">Consumption</h6>

<p>A regex match <strong>consumes</strong> the characters it matches. How it does this is important as well as the fact.</p>

<p>The fact of consumption makes some matching and replacement harder because you might want to match on a long pattern, but only replace a small amount. Capture groups help, but it ain’t alway easy.</p>

<p>The type of consumption is also very important. The types are</p>

<ul>
  <li>
    <p>**Greedy: ** [Julia’s default] matches (consumes) as much as it can.</p>

    <div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">match</span><span class="x">(</span><span class="n">r</span><span class="s">"^(.*)ab"</span><span class="x">,</span> <span class="s">"bcdabdcbabcd"</span><span class="x">)</span>
<span class="kt">RegexMatch</span><span class="x">(</span><span class="s">"bcdabdcbab"</span><span class="x">,</span> <span class="mi">1</span><span class="o">=</span><span class="s">"bcdabdcb"</span><span class="x">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Reluctant:</strong> by putting an extra ? after an quantifier (?,*,+)  you make it reluctant. This matches as little as possible.</p>

    <div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">match</span><span class="x">(</span><span class="n">r</span><span class="s">"^(.*?)ab"</span><span class="x">,</span> <span class="s">"bcdabdcbabcd"</span><span class="x">)</span>
<span class="kt">RegexMatch</span><span class="x">(</span><span class="s">"bcdab"</span><span class="x">,</span> <span class="mi">1</span><span class="o">=</span><span class="s">"bcd"</span><span class="x">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Possessive:</strong> by putting an extra + after a quantifier (?,*,+) you make it possessive. This matches as much as possible in a more efficient manner because it won’t give back once it has found some match.</p>

    <div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">match</span><span class="x">(</span><span class="n">r</span><span class="s">"^(.*+)ab"</span><span class="x">,</span> <span class="s">"bcdabdcbabcd"</span><span class="x">)</span>
<span class="nb">nothing</span>
</code></pre></div>    </div>

    <p>The last one is strange and to be honest I don’t think I really understand it. It is meant to be greedy without backtracking, so it should be matching the same, but ???</p>
  </li>
</ul>

<p>https://www.computerworld.com/article/2786107/regular-expression-tutorial-part-5–greedy-and-non-greedy-quantification.html</p>

<p>https://stackoverflow.com/questions/5319840/greedy-vs-reluctant-vs-possessive-qualifiers</p>

<h6 id="operator-precedence">Operator precedence</h6>

<p>Precedence determines the order in which operations are interpreted, similar to BODMATH  (Brackets, Orders (square roots and powers), Division/Multiplication, Addition/Subtraction) in conventional arithmetic. Hence <code class="language-plaintext highlighter-rouge">2 + 4 * 5 = 2 + 20 = 22</code>.</p>

<p>The precedence of operators doesn’t seem to be be described often. A very brief desciption is <a href="https://swtch.com/~rsc/regexp/regexp1.html">here</a>. It states that “The operator precedence, from weakest to strongest binding, is first alternation, then concatenation, and finally the repetition operators. Explicit parentheses can be used to force different meanings, just as in arithmetic expressions. Some examples: <code class="language-plaintext highlighter-rouge">ab|cd</code> is equivalent to <code class="language-plaintext highlighter-rouge">(ab)|(cd)</code>; <code class="language-plaintext highlighter-rouge">ab*</code> is equivalent to <code class="language-plaintext highlighter-rouge">a(b*)</code>.” But this doesn’t note that escapes seem to have the highest precedence, or that the precedence of brackets (round, square and curly) is also high, but I don’t know which is highest.</p>

<p>Some experimentation might be needed here.</p>

<h6 id="modifier-flags">Modifier flags</h6>

<p>Most regular expression engines also allow some extras. The most common one I use is “case independence”, i.e., instead of having to include ‘a’ and ‘A’ in my regex, I can tell it to ignore the case and include both.</p>

<p>Julia has 4 flags:</p>

<ul>
  <li>i – do case insenstive match;</li>
  <li>m – treat strings as multiline;</li>
  <li>s – treat strings as single line; and</li>
  <li>x – allows whitespace in the regex definition, so that you can make this more human readable.</li>
</ul>

<p>The most common one for me is ‘i’, so that you can do things like</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">match</span><span class="x">(</span><span class="n">r</span><span class="s">"cruel"</span><span class="n">i</span><span class="x">,</span> <span class="s">"Goodbye, Oh Cruel World!</span><span class="se">\n</span><span class="s">"</span><span class="x">)</span>
<span class="kt">RegexMatch</span><span class="x">(</span><span class="s">"Cruel"</span><span class="x">)</span>
</code></pre></div></div>

<h6 id="theory">Theory</h6>

<p>The theory of languages is actually very mathsy. The classic example is the <a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">Chomsky Hierachy</a>, which have regular languages or grammars at the base. Regexes started as regular langauges, but feature creep added components that broke that, so they are no longer.</p>

<p>https://sodocumentation.net/regex</p>

<h6 id="string-macros">String macros</h6>

<p>Ever wonder what <code class="language-plaintext highlighter-rouge">r"stuff"</code> or <code class="language-plaintext highlighter-rouge">s"other stuff"</code> actually do? They’re using a <em>string macro</em>, turning</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">mymacro</span><span class="s">"string"</span>
</code></pre></div></div>

<p>into</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@mymacro_str</span> <span class="s">"string"</span>
</code></pre></div></div>

<p>There are a whole bunch of such string macros:</p>

<ul>
  <li>b”hello” converts into a byte array (a traditional string);</li>
  <li>doc”string” is used in constructing the docs for Julia from markdown;</li>
  <li>L”stuff” as part of <a href="https://github.com/stevengj/LaTeXStrings.jl"><code class="language-plaintext highlighter-rouge">LaTeXSAtrings</code></a> creates a LaTeX string.</li>
</ul>

<p>and more.</p>

<p>https://sodocumentation.net/julia-lang/topic/5817/string-macros</p>

<h2 id="summary">Summary</h2>

<p>Regular expressions are sdcary at first but most of the basic things you might want to do with them aren’t too hard and they are very powerful.</p>

<p>But in the end they are still scary ;)</p>

<p><img src="/Users/mroughan/Dropbox/Classes_and_postgrads/Julia/XKCD/regex_golf_2x.png" alt="regex_golf_2x" /></p>

<p>https://xkcd.com/1313/</p>

<h2 id="links">Links</h2>

<p>https://en.wikipedia.org/wiki/Regular_expression</p>

<p>Perl docs and tutes</p>

<ul>
  <li>https://perldoc.perl.org/perlre</li>
  <li>https://perldoc.perl.org/perlrequick</li>
  <li>https://www.tutorialspoint.com/perl/perl_regular_expressions.htm</li>
  <li>https://www.perltutorial.org/perl-regular-expression/</li>
  <li>https://perldoc.perl.org/perlretut</li>
</ul>

<p>PCRE</p>

<ul>
  <li>https://www.pcre.org/</li>
  <li>http://pcre.org/pcre.txt</li>
  <li>https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions</li>
</ul>

<p>Cheat Sheets (Perl focussed)</p>

<ul>
  <li>https://perlmaven.com/regex-cheat-sheet</li>
  <li>https://www.debuggex.com/cheatsheet/regex/pcre</li>
</ul>

<p>Regular expression implementation and programming language theory</p>

<ul>
  <li>https://www.npopov.com/2012/06/15/The-true-power-of-regular-expressions.html</li>
  <li>https://www.perlmonks.org/?node_id=809842</li>
  <li>https://cs.stackexchange.com/questions/4839/which-languages-do-perl-compatible-regular-expressions-recognize</li>
  <li>https://swtch.com/~rsc/regexp/regexp1.html</li>
  <li>https://swtch.com/~rsc/regexp/</li>
</ul>

<p>Julia Regexes</p>

<ul>
  <li>https://riptutorial.com/julia-lang/example/20707/regex-literals</li>
  <li>https://sodocumentation.net/julia-lang/topic/5890/regexes</li>
  <li>https://docs.julialang.org/en/v1/manual/strings/#Regular-Expressions</li>
  <li>https://www.geeksforgeeks.org/regular-expressions-in-julia/</li>
</ul>

<p>Cross-language comparison</p>

<ul>
  <li>https://cs.lmu.edu/~ray/notes/regex/</li>
  <li>https://medium.com/factory-mind/regex-tutorial-a-simple-cheatsheet-by-examples-649dc1c3f285</li>
</ul>


  </div>

</article>

      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        
        <p class="copyright">JuLiase maintained by <a href="https://github.com/Juliaise">Juliaise</a></p>
        
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>
  </body>
</html>
