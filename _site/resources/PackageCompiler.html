<!DOCTYPE html>
<html lang="en-US">

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,maximum-scale=2">
    <link rel="stylesheet" type="text/css" media="screen" href="/assets/css/style.css?v=cba3886efdc87b33856ab61e4b0a3cdb377e926c">

<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>PackageCompiler.jl | JuLiase</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="PackageCompiler.jl" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Julia users group, Adelaide, South Australia&lt;p&gt; A space for coders of all backgrounds and ability to talk Julia." />
<meta property="og:description" content="Julia users group, Adelaide, South Australia&lt;p&gt; A space for coders of all backgrounds and ability to talk Julia." />
<link rel="canonical" href="http://localhost:4000/resources/PackageCompiler.html" />
<meta property="og:url" content="http://localhost:4000/resources/PackageCompiler.html" />
<meta property="og:site_name" content="JuLiase" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="PackageCompiler.jl" />
<script type="application/ld+json">
{"@type":"WebPage","headline":"PackageCompiler.jl","url":"http://localhost:4000/resources/PackageCompiler.html","description":"Julia users group, Adelaide, South Australia&lt;p&gt; A space for coders of all backgrounds and ability to talk Julia.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZMMPPCHMBK"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZMMPPCHMBK');
</script>


<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->

  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          
            <a id="forkme_banner" href="https://github.com/Juliaise/juliaise.github.io">View on GitHub</a>
          

          <h1 id="project_title">JuLiase</h1>
          <h2 id="project_tagline">Julia users group, Adelaide, South Australia<p> A space for coders of all backgrounds and ability to talk Julia.</h2>

          
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1 id="packagecompilerjl">PackageCompiler.jl</h1>

<p>By Matthew Roughan, September, 2021, <code class="language-plaintext highlighter-rouge">Julia v1.6.0, PackageCompiler.jl v1.4.1</code></p>

<p>Julia is fast out of the box. But it does have one headache, which is that when you start it up and load packages, that can be quite slow. That is annoying if you signed up to Julia for the speed.</p>

<p><code class="language-plaintext highlighter-rouge">PackageCompile.jl</code> addresses this problem.</p>

<p>It also provides a means to create stand-alone Julia programs that some could run on their computer without installing Julia themselves.</p>

<p>It’s simple to use, and has big benefits. So let’s have a look at how and why it works.</p>

<h2 id="links">Links</h2>

<p>Main documents</p>

<ul>
  <li>https://github.com/JuliaLang/PackageCompiler.jl</li>
  <li>https://julialang.github.io/PackageCompiler.jl/dev/</li>
</ul>

<p>Tutorials</p>

<ul>
  <li>https://medium.com/coffee-in-a-klein-bottle/speeding-up-julia-precompilation-97f39d151a9f</li>
  <li>https://julialang.github.io/PackageCompiler.jl/dev/examples/plots.html</li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>Julia uses Just-In-Time (JIT) compilation. When you call a function for the first time [1], Julia compiles it. Subsequent calls to the function don’t need to repeat this process, but it means the first call will be slow. That is problematic if:</p>

<ol>
  <li>You only call the function once, for instance, if you are using a Julia script from another source, e.g., using it in batch mode from a shell script.</li>
  <li>You want to compile a lot of functions, e.g., when you load a series of big packages at the start of your session.</li>
  <li>You need to restart Julia often, such as when you are creating new data structures.</li>
</ol>

<p>The package compiler fixes this issue.</p>

<p>A second problem is that not everyone wants to install Julia in order to use your code. Stand-alone apps are a standard way to distribution software functionality and the package compiler let’s you create such apps.</p>

<p>Finally, the package compiler can create a C-library that you could call from another language (if it can’t call Julia directly).</p>

<p>I won’t talk about the last two tricks here (they are harder) but its well worth knowing they are possible.</p>

<h2 id="what-to-do">What to do</h2>

<p>A custom <code class="language-plaintext highlighter-rouge">sysimage</code> is how we get pre-compilation going to make things fast. A <code class="language-plaintext highlighter-rouge">sysimage</code> is like a Julia session with preloaded packages, global variables and your functions already compiled. When you run <code class="language-plaintext highlighter-rouge">julia</code> you are running their default <code class="language-plaintext highlighter-rouge">sysimage</code> which has the Julia compiler, the standard libraries and the REPL built in, but all those tasty packages you like to use are not.</p>

<p>So how do we do it: there are 4 easy steps.</p>

<ol>
  <li>Install <code class="language-plaintext highlighter-rouge">PackageCompiler</code> as you would any other package but you will need to have a C-compiler installed on your computer. That will be system dependent, but its a standard thing to do (on Windows the package install will do it for you. On Mac’s <code class="language-plaintext highlighter-rouge">homebrew</code> might be a good choice. On linux, <code class="language-plaintext highlighter-rouge">gcc</code> or <code class="language-plaintext highlighter-rouge">clang</code>.)</li>
  <li>Create a pre-compilation file to help the compiler work out what it should pre-compile.</li>
  <li>Run the function <code class="language-plaintext highlighter-rouge">create_sysimage</code>, which will create a <code class="language-plaintext highlighter-rouge">.so</code> shared library file.</li>
  <li>Start Julia using the new <code class="language-plaintext highlighter-rouge">.so</code> file using the <code class="language-plaintext highlighter-rouge">--sysimage</code> flag. If you are calling Julia using the command line this is easy. If calling from Jupyter you need to install a new kernel with the <code class="language-plaintext highlighter-rouge">--sysimage</code> command.</li>
</ol>

<h2 id="example">Example</h2>

<p>Making fast plots: this example comes largely from https://julialang.github.io/PackageCompiler.jl/dev/examples/plots.html, but I like <code class="language-plaintext highlighter-rouge">PlotlyJS</code> so I have added that.</p>

<p>One of the most common problems in Julia is the “time to first plot.” The plot libraries are big and take a while to load. For example take the script (I am putting this in <code class="language-plaintext highlighter-rouge">precompile_plots.jl</code>) .</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">Plots</span>
<span class="k">using</span> <span class="n">PlotlyJS</span>
<span class="n">plotlyjs</span><span class="x">()</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">Plots</span><span class="o">.</span><span class="n">plot</span><span class="x">(</span><span class="n">rand</span><span class="x">(</span><span class="mi">5</span><span class="x">),</span> <span class="n">rand</span><span class="x">(</span><span class="mi">5</span><span class="x">))</span>
</code></pre></div></div>

<p>Just running this (the first time) took nearly 20 seconds on my fairly beefy computer, e.g.,</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@time</span> <span class="n">include</span><span class="x">(</span><span class="s">"precompile_plots.jl"</span><span class="x">)</span>
 <span class="mf">17.081378</span> <span class="n">seconds</span> <span class="x">(</span><span class="mf">43.79</span> <span class="n">M</span> <span class="n">allocations</span><span class="o">:</span> <span class="mf">2.617</span> <span class="n">GiB</span><span class="x">,</span> <span class="o">...</span>
</code></pre></div></div>

<p>The second time was much, much faster:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@time</span> <span class="n">include</span><span class="x">(</span><span class="s">"precompile_plots.jl"</span><span class="x">)</span>
  <span class="mf">0.002361</span> <span class="n">seconds</span> <span class="x">(</span><span class="mf">2.56</span> <span class="n">k</span> <span class="n">allocations</span><span class="o">:</span> <span class="mf">218.078</span> <span class="n">KiB</span><span class="x">)</span>
</code></pre></div></div>

<p>You can see the massive difference.</p>

<p>I will use my <code class="language-plaintext highlighter-rouge">precompile_plots.jl</code> file above for Step 2. We perfom Step 3 in an interactive Julia REPL by calling two commands:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">PackageCompiler</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">create_sysimage</span><span class="x">([</span><span class="o">:</span><span class="n">Plots</span><span class="x">,</span> <span class="o">:</span><span class="n">PlotlyJS</span><span class="x">],</span> 
    				<span class="n">sysimage_path</span><span class="o">=</span><span class="s">"sys_plots.so"</span><span class="x">,</span> 	
    				<span class="n">precompile_execution_file</span><span class="o">=</span><span class="s">"precompile_plots.jl"</span><span class="x">)</span>
</code></pre></div></div>

<p>That process won’t be fast – on my machine it took 196 seconds (more than 3 minutes).</p>

<p>Now quit out of Julia, you should see a file called <code class="language-plaintext highlighter-rouge">sys_plots.so</code>. This is your <code class="language-plaintext highlighter-rouge">sysimage</code> or shared library file.</p>

<p>For Step 4 just restart Julia with the command (on the command line)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>julia --sysimage sys_plots.so
</code></pre></div></div>

<p>When I do this, and then rerun my script, I get the following:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@time</span> <span class="n">include</span><span class="x">(</span><span class="s">"precompile_plots.jl"</span><span class="x">)</span>
 <span class="mf">0.922924</span> <span class="n">seconds</span> <span class="x">(</span><span class="mf">2.67</span> <span class="n">M</span> <span class="n">allocations</span><span class="o">:</span> <span class="mf">158.302</span> <span class="n">MiB</span><span class="x">,</span> <span class="o">...</span>
</code></pre></div></div>

<p>Note that this is still compiling something (it has more memory allocations and takes longer). So we could perhaps improve our pre-compile script.</p>

<p>However that’s all you fundamentally need to get a massive speed up in time-to-first-plot.</p>

<p>If you want it to use it from within Jupyter or VSCode you’re going to have to make sure they use the <code class="language-plaintext highlighter-rouge">sysimage</code>.</p>

<h2 id="how-it-works">How it works</h2>

<p>The docs for <code class="language-plaintext highlighter-rouge">PackageCompiler</code> describe Julia’s compilation as Just-Ahead-Of-Time (JAOT) rather tha JIT. Julia doesn’t recompile code based on run-time data, which is perhaps a property of JIT compilation. That means we can pre-compile code before running it.</p>

<p>The shared library <code class="language-plaintext highlighter-rouge">sysimage</code> provides Julia with a set of functionality that has be pre-compiled.</p>

<p>The term “pre-compiled” is apparently misleading. Julia’s dynamic typing may still need to do some work, so everything isn’t completely sorted. Julia needs to work out what types the functions will be compiled for. <code class="language-plaintext highlighter-rouge">PackageCompiler</code> does that by tracing an exemplar session and recording which methods were used. The pre-compile file provides the exemplar session, so include commands in it that you might want to be fast. But you don’t have to do everything. It seems OK at inferring what it needs, if not perfect.</p>

<p>The <code class="language-plaintext highlighter-rouge">create_sysimage</code> function has lots of options, e.g., see https://julialang.github.io/PackageCompiler.jl/dev/refs.html. For instance, you can input a vector of pre-compilation files.</p>

<p>Useful bits and pieces:</p>

<ul>
  <li>There is a dictionary that keeps track of loaded modules called <code class="language-plaintext highlighter-rouge">Base.loaded_modules</code></li>
  <li>You can do all this from the command line using the compilers yourself – that seems hard to me. But it shows you what is happening.</li>
</ul>

<h2 id="no-free-lunch">No free lunch</h2>

<p>There is no free lunch, only free snacks. The costs of pre-compiling are</p>

<ol>
  <li>You are locked into the pre-compiled code, <em>i.e.,</em> the packages etc. that were installed in the <code class="language-plaintext highlighter-rouge">sysimage</code> are the ones that will be used.</li>
  <li>Running Julia with custom <code class="language-plaintext highlighter-rouge">sysimages</code> will take up extra memory because they include more code. My <code class="language-plaintext highlighter-rouge">sysimage</code> was a file 214 MB in size. When I start Julia without it, the session uses 97.4 MB. When I run it with the <code class="language-plaintext highlighter-rouge">sysimage</code> it takes 172.9 MB. The difference is large, but probably not important for most applications I have in mind, particular as Julia uses 246 MB if I load in <code class="language-plaintext highlighter-rouge">Plots</code> and <code class="language-plaintext highlighter-rouge">PlotlyJS</code> manually.</li>
  <li>Starting Julia with a custom <code class="language-plaintext highlighter-rouge">sysimage</code> will be slightly slower than starting a vanilla Julia session, though much, much faster than starting Julia and loading the packages. This is because there is a small extra time involved in loading the extra pre-compiled code but we are talking about 10s of milliseconds.</li>
  <li>There are some tricks and traps. The first time I created the example above, I decide to use <code class="language-plaintext highlighter-rouge">PyPlot</code> and when I tried to load the <code class="language-plaintext highlighter-rouge">sysimage</code> Julia crashed with a segmentation fault. I think it was because it didn’t want to create all that ugly Python stuff. So there are some limits on what packages you can pre-compile.</li>
</ol>

<h2 id="notes">Notes</h2>

<p>[1] Julia pre-compiles many standard functions and operators, such as <code class="language-plaintext highlighter-rouge">+</code> so these are OK.</p>

<p>[2] A <code class="language-plaintext highlighter-rouge">.so</code> file is a shared library file. It is a pretty standard thing these days. It provides compiled resources (called objects, but actually a bit different, <em>e.g.</em>, methods) that can be loaded into another program so that the calling application doesn’t have to provide them. The “shared” part of the name comes from the fact that it is dynamically linked at <strong>run time</strong> [3], and that means that these can be easily updated and shared between multiple applications at once. The alternative – static linking – requires that the methods become part of the calling application when it is compiled, which makes them less flexible and blows up the size of the application particularly if the application only needs one small part of a larger library.</p>

<p>Note that a <code class="language-plaintext highlighter-rouge">.so</code> file will be system specific, so if you create one on your Mac, it won’t work on your Linux box.</p>

<p>https://stackoverflow.com/questions/9809213/what-are-a-and-so-files</p>

<p>https://www.baeldung.com/linux/a-so-extension-files</p>

<p>[3] The <code class="language-plaintext highlighter-rouge">run time</code> being referred to here is the time at which you run <code class="language-plaintext highlighter-rouge">julia</code>, not the time at which you run the functions themselves (I think).</p>


      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        
        <p class="copyright">JuLiase maintained by <a href="https://github.com/Juliaise">Juliaise</a></p>
        
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>
  </body>
</html>
